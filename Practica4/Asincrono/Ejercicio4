/* Simular la atención en un locutorio con 10 cabinas telefónicas, el cual tiene un empleado
que se encarga de atender a N clientes. Al llegar, cada cliente espera hasta que el empleado
le indique a qué cabina ir, la usa y luego se dirige al empleado para pagarle. El empleado
atiende a los clientes en el orden en que hacen los pedidos. A cada cliente se le entrega un
ticket factura por la operación.
a) Implemente una solución para el problema descrito.
b) Modifique la solución implementada para que el empleado dé prioridad a los que
terminaron de usar la cabina sobre los que están esperando para usarla.
Nota: maximizar la concurrencia; suponga que hay una función Cobrar() llamada por el
empleado que simula que el empleado le cobra al cliente. */

/* Inciso A*/


chan pedirCabina(int)
chan asignarCabina(int)
chan pagar(int, int)
chan ticket[N](text)

Process Cliente[id: 0..C-1]{
    int numCabina;
    text ticket;

    send pedirCabina(id);
    receive asignarCabina(numCabina);
    // Usar cabina
    send pagar(id, numCabina);
    receive ticket[id](ticket);
}

Process Empleado{
    int idCliente;
    int numCabina;
    int i;
    cola cabinaLibre;
    text comprobante;

    for i:=0 to 9 do
        cabinaLibre.push(i);
    while(true){
        if (not empty(cabinaLibre) and not empty(pedirCabina)){
            receive pedirCabina(idCliente);
            numCabina := cabinaLibre.pop();
            send asignarCabina(idCliente)(numCabina);
        }
        else{
            receive pagar(idCliente, numCabina);
            Cobrar();
            comprobante := "Ticket de cliente " + idCliente + " por cabina " + numCabina;
            send ticket[idCliente](comprobante);
            cabinaLibre.push(numCabina);
        }
    }
}

/*Inciso B*/

chan pedirCabina(int)
chan asignarCabina(int)
chan pagar(int, int)
chan ticket[N](text)

Process Empleado {
    cola cabinaLibre;
    int idCliente;
    int numCabina;
    text comprobante;
    int i;
    for i:=0 to 9 do cabinaLibre.push(i);
    while(true) do
        if(not empty(pagar)){
            receive pagar(idCliente, numCabina);
            Cobrar();
            comprobante := "Ticket de cliente " + idCliente + " por cabina " + numCabina;
            send ticket[idCliente](comprobante);
            cabinaLibre.push(numCabina);
        }
    
        else if(not empty(cabinaLibre) and not empty(pedirCabina) and empty(pagar)){
        receive pedirCabina(idCliente);
        numCabina := cabinaLibre.pop();
        send asignarCabina(idCliente)(numCabina);
        }
    }
}

Process Cliente[id: 0..N-1] {
    int numCabina;
    text miTicket;

    // 1. Pide cabina (canal: pedirCabina)
    send pedirCabina(id);

    // 2. Espera asignación (canal: asignarCabina[id])
    receive asignarCabina[id](numCabina);

    // 3. Usa la cabina
    delay(tiempoDeUso);

    // 4. Paga y libera (canal: pagar)
    send pagar(id, numCabina);

    // 5. Espera su ticket (canal: ticket[id])
    receive ticket[id](miTicket);
}
